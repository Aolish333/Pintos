; 对应原书代码：c11_mbr.asm
; 文件说明：硬盘主引导扇区代码 
; 创建日期：2014-04-01
 
; 设置堆栈指针，
; 在这里堆栈指针指向0x7c00，
; 虽然与代码段为相同的地址，
; 但堆栈指针将向0x7c00以下的地址发展，
; 代码段则向0x7c00以上发展，
; 所以在这里不用担心地址冲突
mov ax, cs
mov ss, ax
mov sp, 0x7c00

; 因为现在仍然处于实模式下，
; 所以在GDT中安装描述符的时候，
; 必须将GDT的线性地址（即物理地址）转换成为逻辑段地址和偏移地址
mov ax, [cs:gdt_base + 0x7c00]        ; 低16位 
mov dx, [cs:gdt_base + 0x7c00 + 0x02] ; 高16位 
; 以下几行代码将线性基地址转换成为逻辑地址，
; 方法是将dx:ax除以16，
; 得到的商是逻辑段地址，
; 余数是偏移地址，
; 这种方法很好理解嘛，
; 就是将逻辑段地址和偏移地址拼凑成物理地址的逆过程
mov bx, 16
div bx
mov ds, ax ; 令ds指向该段以进行操作
mov bx, dx ; 段内起始偏移地址 
 
; 很多时候，寄存器和内存单元的初始值会为0，
; 再加上程序设计有问题，
; 就会无意中用全0的索引来选择描述符，
; 所以处理器要求将第一个描述符定义为空描述符
mov dword [bx + 0x00], 0x00
mov dword [bx + 0x04], 0x00
 
; 创建保护模式下的代码段描述符；
; 低32位为0x7c0001ff，
; 即二进制的0110 1100 0000 0000 0000 0001 1111 1111；
; 高32位为0x00409800，
; 即二进制的0000 0000 0100 0000 1001 1000 0000 0000；
; 通过观察以上两条二进制，
; 同时对应原书第188页的图11-4，
; 我们不难得出该代码段的一些信息：
;     线性基地址为0x00007c00
;     段界限为0x001ff，粒度为字节（G = 0）。该段的长度为512字节
;     属于存储器的段（S = 1）
;     这是一个32位的段（D = 1）
;     该段目前位于内存中（P = 1）
;     段的特权级为0（DPL = 00）
;     这是一只能执行的代码段（TYPE = 1000）
mov dword [bx + 0x08], 0x7c0001ff
mov dword [bx + 0x0c], 0x00409800
 
; 创建保护模式下的一个数据段的描述符；
; 同理，我们也可以得出该代码段的一些信息：
;     线性基地址为0x000b8000
;     段界限为0x0ffff，粒度为字节（G = 0）。即，该段的长度为64KB
;     属于存储区的段（S = 1）
;     这是一个32位的段（D = 1）
;     该段目前位于内存中（P = 1）
;     段的特权级为0（DPL = 00）
;     这是一个可读可写、向上扩展的数据段（TYPE = 0100）
mov dword [bx + 0x10], 0x8000ffff
mov dword [bx + 0x14], 0x0040920b
 
; 创建保护模式下用于安装栈段的描述符；
; 同理，我们也可以得出该栈段的一些信息：
;     线性基地址为0x00000000
;     段界限为0x07a00，粒度为字节（G = 0）
;     属于存储器的段（S = 1）
;     这是一个32位的段（D = 1）
;     该段目前位于内存中（P = 1）
;     段的特权级为0（DPL = 00）
;     这是一个可读可写、向下扩展的数据段，在这里是栈段（TYPE = 0010）
mov dword [bx + 0x18], 0x00007a00
mov dword [bx + 0x1c], 0x00409600
 
; 初始化描述符表寄存器GDTR；
; 为啥是一个字的大小呢？
; 我也不知道，所以你要是知道的话，可以联系我
mov word [cs:gdt_size + 0x7c00], 31 ; 描述符表的界限（总字节数减1）

; 加载描述符表的线性基地址和界限到GDTR寄存器
lgdt [cs:gdt_size + 0x7c00]

; 先从南桥芯片内的端口读入原始数据，
; 接着，将第2位（位1）置1，
; 然后再写入该端口，
; 这样，就打开了A20
in al, 0x92
or al, 0000_0010B
out 0x92, al
 
; 保护模式下的中断机制和实模式不一样，
; 所以，原有的中断向量表不再适用，
; 而且你必须知道的是，
; 在保护模式下，
; BIOS中断都不能再使用，因为它们是实模式下的代码；
; 所以在重新设置保护模式下的中断环境之前，必须关闭当前中断
cli 

; 这里有一个特别的寄存器cr0，
; 它是一个32位的寄存器，
; 包含了一系列用于控制处理器操作模式和运行状态的标志位，
; 它的第1位（位0）是保护模式允许位（Protection Enable，PE），
; 是开启保护模式的门把手，
; 如果把该位置“1”，则处理器进入保护模式，
; 按照保护模式的规则运行
mov eax, cr0 ; 将cr0原有的内容传送到寄存器eax
or eax, 1    ; 将其第1位（位0）置“1”
mov cr0, eax ; 将修改后的内容重新写回cr0，这直接导致处理器变为在保护模式下运行
 
; 以下进入保护模式
jmp dword 0x0008:flush ; 16位的描述符选择子：32位偏移
                       ; 清流水线并串行化处理器

; 32位代码段
[bits 32]
 
flush: 
    mov cx, 00000000000_10_000B ; 加载数据段选择子(0x10)
    mov ds, cx

    ; 以下在屏幕上显示"Protect mode OK." 
    ; 因为没有使用段超越前缀，
    ; 所以默认使用数据段寄存器ds
    mov byte [0x00], 'P'
    mov byte [0x02], 'r'
    mov byte [0x04], 'o'
    mov byte [0x06], 't'
    mov byte [0x08], 'e'
    mov byte [0x0a], 'c'
    mov byte [0x0c], 't'
    mov byte [0x0e], ' '
    mov byte [0x10], 'm'
    mov byte [0x12], 'o'
    mov byte [0x14], 'd'
    mov byte [0x16], 'e'
    mov byte [0x18], ' '
    mov byte [0x1a], 'O'
    mov byte [0x1c], 'K'

    ; 以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
    mov cx, 00000000000_11_000B ; 加载堆栈段选择子
    mov ss, cx
    mov esp, 0x7c00
 
    mov ebp, esp  ; 保存堆栈指针 
    push byte '.' ; 压入立即数（字节）
 
    sub ebp, 4
    cmp ebp, esp   ; 判断压入立即数时，ESP是否减4 
    jnz ghalt
    pop eax
    mov [0x1e], al ; 显示句点 
 
    ghalt:
        hlt ; 已经禁止中断，将不会被唤醒 
 
; -------------------------------------------------------------------------------

gdt_size dw 0
; gtt_base在这里代表GDT的起始线性地址，
; 在这里用了一双字进行初始化，
; 因为现在的地址书32位的，
; 所以对应的地址是0x00007e00啦，
; 另外0x00007e00正好是主引导扇区程序512字节之后的位置
gdt_base dd 0x00007e00
 
times 510 - ($ -$$) db 0
                    db 0x55, 0xaa
